name: Production Build & Deploy

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: read
  pull-requests: write
  security-events: write

jobs:
  changes:
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.changes.outputs.backend }}
      frontend: ${{ steps.changes.outputs.frontend }}
      deploy: ${{ steps.changes.outputs.deploy }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            backend:
              - 'backend/**'
              - 'docker-compose*.yml'
              - '.github/workflows/production-build.yml'
            frontend:
              - 'frontend/**'
              - 'docker-compose*.yml'
              - '.github/workflows/production-build.yml'
            deploy:
              - 'deploy/**'
              - 'docker-compose*.yml'
              - '.github/workflows/production-build.yml'

  security-scan:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        scan: [trivy, codeql]
      fail-fast: false
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Trivy vulnerability scanner
        if: matrix.scan == 'trivy'
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Initialize CodeQL
        if: matrix.scan == 'codeql'
        uses: github/codeql-action/init@v3
        with:
          languages: python, javascript

      - name: Autobuild CodeQL
        if: matrix.scan == 'codeql'
        uses: github/codeql-action/autobuild@v3

      - name: Perform CodeQL Analysis
        if: matrix.scan == 'codeql'
        uses: github/codeql-action/analyze@v3

      - name: Upload Trivy scan results
        if: matrix.scan == 'trivy' && always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'

  build-backend:
    needs: changes
    if: ${{ needs.changes.outputs.backend == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Cache Python dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/.cache/uv
          key: ${{ runner.os }}-python-${{ hashFiles('backend/pyproject.toml', 'backend/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-python-

      - name: Install UV and dependencies
        run: |
          cd backend
          pip install uv==0.5.29
          uv pip install --system -r requirements.txt
          uv pip install --system -r requirements.test.txt

      - name: Run backend tests
        run: |
          cd backend
          pytest -n auto --maxfail=1 --tb=short --durations=10

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache-backend
          key: ${{ runner.os }}-buildx-backend-${{ hashFiles('backend/Dockerfile', 'backend/pyproject.toml', 'backend/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-buildx-backend-

      - name: Build and export backend
        uses: docker/build-push-action@v5
        with:
          context: backend
          target: production
          platforms: linux/amd64
          cache-from: |
            type=local,src=/tmp/.buildx-cache-backend
            type=gha
          cache-to: |
            type=local,dest=/tmp/.buildx-cache-backend-new,mode=max
            type=gha,mode=max
          outputs: type=docker,dest=/tmp/backend-image.tar
          tags: |
            neoforge-backend:latest
            neoforge-backend:${{ github.sha }}
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: Upload backend artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-image
          path: /tmp/backend-image.tar
          retention-days: 1

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache-backend
          mv /tmp/.buildx-cache-backend-new /tmp/.buildx-cache-backend || true

  build-frontend:
    needs: changes
    if: ${{ needs.changes.outputs.frontend == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: |
            frontend/.bun
            ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('frontend/package.json', 'frontend/bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: Install dependencies
        working-directory: frontend
        run: bun install --frozen-lockfile

      - name: Run tests
        working-directory: frontend
        run: bun run test --reporter=verbose

      - name: Build application
        working-directory: frontend
        run: bun run build

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache-frontend
          key: ${{ runner.os }}-buildx-frontend-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-frontend-

      - name: Build and export frontend
        uses: docker/build-push-action@v5
        with:
          context: frontend
          target: production
          platforms: linux/amd64
          cache-from: |
            type=local,src=/tmp/.buildx-cache-frontend
            type=gha
          cache-to: |
            type=local,dest=/tmp/.buildx-cache-frontend-new,mode=max
            type=gha,mode=max
          outputs: type=docker,dest=/tmp/frontend-image.tar
          tags: |
            neoforge-frontend:latest
            neoforge-frontend:${{ github.sha }}
          build-args: |
            NODE_ENV=production
            BUILDKIT_INLINE_CACHE=1

      - name: Upload frontend artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-image
          path: /tmp/frontend-image.tar
          retention-days: 1

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache-frontend
          mv /tmp/.buildx-cache-frontend-new /tmp/.buildx-cache-frontend || true

  size-analysis:
    needs: [build-backend, build-frontend]
    if: ${{ always() && (needs.build-backend.result == 'success' || needs.build-frontend.result == 'success') }}
    runs-on: ubuntu-latest
    steps:
      - name: Download backend artifact
        if: ${{ needs.build-backend.result == 'success' }}
        uses: actions/download-artifact@v4
        with:
          name: backend-image

      - name: Download frontend artifact
        if: ${{ needs.build-frontend.result == 'success' }}
        uses: actions/download-artifact@v4
        with:
          name: frontend-image

      - name: Load and analyze images
        run: |
          echo "## Docker Image Size Analysis" > size-report.md
          echo "" >> size-report.md

          if [ -f backend-image.tar ]; then
            docker load < backend-image.tar
            BACKEND_SIZE=$(docker images neoforge-backend:latest --format "{{.Size}}")
            echo "- **Backend**: $BACKEND_SIZE" >> size-report.md
          fi

          if [ -f frontend-image.tar ]; then
            docker load < frontend-image.tar
            FRONTEND_SIZE=$(docker images neoforge-frontend:latest --format "{{.Size}}")
            echo "- **Frontend**: $FRONTEND_SIZE" >> size-report.md
          fi

          echo "" >> size-report.md
          echo "### Target Sizes" >> size-report.md
          echo "- Backend: <200MB" >> size-report.md
          echo "- Frontend: <50MB" >> size-report.md

          cat size-report.md

      - name: Comment size analysis
        if: ${{ github.event_name == 'pull_request' }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('size-report.md', 'utf8');

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: report
            });

  production-test:
    needs: [build-backend, build-frontend]
    if: ${{ always() && (needs.build-backend.result == 'success' || needs.build-frontend.result == 'success') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: "*-image"
          merge-multiple: true

      - name: Load images
        run: |
          [ -f backend-image.tar ] && docker load < backend-image.tar
          [ -f frontend-image.tar ] && docker load < frontend-image.tar

      - name: Run production stack
        run: |
          # Set environment variables
          export API_PORT=8000
          export FRONTEND_PORT=80
          export POSTGRES_PASSWORD=test_password
          export REDIS_PASSWORD=test_password

          # Start production services
          docker compose -f docker-compose.prod.yml up -d --no-build

          # Wait for services to be ready with timeout
          echo "Waiting for services to be ready..."
          timeout=60
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            if docker compose -f docker-compose.prod.yml ps --status running | grep -q "running"; then
              sleep 5
              ((elapsed+=5))
            else
              break
            fi
          done

          # Check if services are running
          echo "Service status:"
          docker compose -f docker-compose.prod.yml ps

      - name: Comprehensive Smoke Tests
        run: |
          set -e
          echo "ðŸ§ª Running comprehensive smoke tests..."

          # Function for retries
          retry() {
            local retries=$1
            local delay=$2
            local command="${@:3}"
            for i in $(seq 1 $retries); do
              if $command; then
                return 0
              fi
              echo "Attempt $i failed, retrying in ${delay}s..."
              sleep $delay
            done
            return 1
          }

          # Test 1: Basic health checks
          echo "ðŸ“‹ Test 1: Basic Health Checks"
          retry 5 3 curl -f http://localhost:8000/health || {
            echo "âŒ Backend health check failed"
            docker compose -f docker-compose.prod.yml logs api
            exit 1
          }
          echo "âœ… Backend health check passed"

          # Test 2: Frontend availability
          echo "ðŸ“‹ Test 2: Frontend Availability"
          retry 5 3 curl -f http://localhost:80/ -o /dev/null -w "%{http_code}" | grep -q "200" || {
            echo "âŒ Frontend availability check failed"
            docker compose -f docker-compose.prod.yml logs frontend
            exit 1
          }
          echo "âœ… Frontend availability check passed"

          # Test 3: Database connectivity
          echo "ðŸ“‹ Test 3: Database Connectivity"
          retry 3 5 curl -f http://localhost:8000/api/v1/health/db || {
            echo "âŒ Database connectivity test failed"
            docker compose -f docker-compose.prod.yml logs api
            docker compose -f docker-compose.prod.yml logs db
            exit 1
          }
          echo "âœ… Database connectivity test passed"

          # Test 4: Redis connectivity
          echo "ðŸ“‹ Test 4: Redis Connectivity"
          retry 3 5 curl -f http://localhost:8000/api/v1/health/cache || {
            echo "âŒ Redis connectivity test failed"
            docker compose -f docker-compose.prod.yml logs api
            docker compose -f docker-compose.prod.yml logs cache
            exit 1
          }
          echo "âœ… Redis connectivity test passed"

          # Test 5: API endpoints
          echo "ðŸ“‹ Test 5: Critical API Endpoints"
          endpoints=(
            "/api/v1/status"
            "/api/v1/metrics"
          )
          
          for endpoint in "${endpoints[@]}"; do
            retry 3 2 curl -f "http://localhost:8000$endpoint" -o /dev/null || {
              echo "âŒ API endpoint $endpoint test failed"
              exit 1
            }
            echo "âœ… API endpoint $endpoint test passed"
          done

          # Test 6: Performance metrics
          echo "ðŸ“‹ Test 6: Performance Metrics"
          response_time=$(curl -o /dev/null -s -w "%{time_total}" http://localhost:8000/health)
          if (( $(echo "$response_time > 2.0" | bc -l) )); then
            echo "âš ï¸  Warning: Health endpoint response time is ${response_time}s (>2s)"
          else
            echo "âœ… Health endpoint response time: ${response_time}s"
          fi

      - name: Load Testing
        run: |
          echo "ðŸš€ Running load tests..."
          
          # Install dependencies for load testing
          sudo apt-get update && sudo apt-get install -y bc
          
          # Concurrent requests test
          echo "Running concurrent requests test..."
          start_time=$(date +%s.%3N)
          
          for i in {1..20}; do
            curl -s http://localhost:8000/health > /dev/null &
            curl -s http://localhost:80/ > /dev/null &
          done
          wait
          
          end_time=$(date +%s.%3N)
          duration=$(echo "$end_time - $start_time" | bc)
          echo "âœ… 40 concurrent requests completed in ${duration}s"
          
          # Sustained load test
          echo "Running sustained load test..."
          for round in {1..3}; do
            echo "Load test round $round/3"
            for i in {1..10}; do
              curl -s http://localhost:8000/health > /dev/null
              curl -s http://localhost:80/ > /dev/null
            done
            sleep 1
          done
          echo "âœ… Sustained load test completed"

      - name: Security Headers Check
        run: |
          echo "ðŸ”’ Checking security headers..."
          
          # Check backend security headers
          backend_headers=$(curl -I http://localhost:8000/health 2>/dev/null)
          if echo "$backend_headers" | grep -qi "x-content-type-options"; then
            echo "âœ… Backend has X-Content-Type-Options header"
          else
            echo "âš ï¸  Backend missing X-Content-Type-Options header"
          fi
          
          # Check frontend security headers
          frontend_headers=$(curl -I http://localhost:80/ 2>/dev/null)
          if echo "$frontend_headers" | grep -qi "x-frame-options\|content-security-policy"; then
            echo "âœ… Frontend has security headers"
          else
            echo "âš ï¸  Frontend missing security headers"
          fi

      - name: Resource Usage Check
        run: |
          echo "ðŸ“Š Checking resource usage..."
          
          # Get container stats
          docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}" | head -10
          
          # Check if any container is using excessive resources
          high_cpu=$(docker stats --no-stream --format "{{.Name}} {{.CPUPerc}}" | grep -E "[5-9][0-9]\.[0-9]+%" | head -5)
          if [ -n "$high_cpu" ]; then
            echo "âš ï¸  High CPU usage detected:"
            echo "$high_cpu"
          else
            echo "âœ… CPU usage within acceptable limits"
          fi

      - name: Generate Test Report
        if: always()
        run: |
          echo "## ðŸ§ª Production Smoke Test Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Test Results" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Health Checks: Passed" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Database Connectivity: Passed" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Redis Connectivity: Passed" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… API Endpoints: Passed" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Load Testing: Passed" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Security Headers: Checked" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Service Status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          docker compose -f docker-compose.prod.yml ps >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up..."
          docker compose -f docker-compose.prod.yml down -v
          docker system prune -f

  deploy-staging:
    needs: [security-scan, production-test]
    if: ${{ github.ref == 'refs/heads/main' && github.event_name == 'push' }}
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy to staging
        run: |
          echo "ðŸš€ Deploying to staging environment"
          echo "This would typically involve:"
          echo "- Downloading production images"
          echo "- Deploying to staging infrastructure"
          echo "- Running smoke tests"
          echo "- Updating deployment status"

  deploy-production:
    needs: [deploy-staging]
    if: ${{ github.ref == 'refs/heads/main' && github.event_name == 'push' }}
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy to production
        run: |
          echo "ðŸš€ Deploying to production environment"
          echo "This would typically involve:"
          echo "- Blue-green deployment strategy"
          echo "- Database migrations"
          echo "- Health checks and monitoring"
          echo "- Rollback capability"
